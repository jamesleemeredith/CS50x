Harvard CS50 - CS50‚Äôs Introduction to Computer Science
official course website: https://cs50.harvard.edu/x/

WEEK 0 - SCRATCH
Essentially, computer programming is about taking some input and creating some output - thus solving a problem. What happens in between the input and output, what we could call a black box, is the focus of this course.

Computers speak binary! It‚Äôs from the term binary digit that we get a familiar term called bit. A bit is a zero or one: on or off.

Binary is used to represent the millions of transistors in your computer turning on or off.

8 bits = 1 byte

8 bits (aka 1 byte) allow us to hold values up to 255

There are actually ternary computers that exist that use ternary rather than binary

But what if we can to use binary to represent things beyond just numbers? Enter character encoding standards!

ASCII is a method of encoding used to convert raw binary to English letters and characters we're more familiar with (ex. 01000001 = "A")

To accommodate characters beyond English, Unicode was developed. Even things like emojis and Chinese characters can be accommodated using Unicode.

But beyond text, how are colors in things like images and video represented in bytes?

RGB!

Each value of R, G, and B is a byte, so a single color in RGB would be 3 bytes (ex. 0,255,255)

How is data used to represent video?
Video is really just a series of images shown in sequence, so we store the image data in much the same way as static image data.

But what about the audio data in a video file?
Much the same way as encoding characters and textual data, we can dedicate bytes to encoding things like the frequency (aka pitch), duration, and volume of a particular sound in an audio file

So if all these different types of data are simply stored as zeros and ones, how does the computer know whether, for example, 72,73,33 is supposed to be the message "HI!" or the color yellow? - It all depends on context! The file type and software we use to open a file will dictate how the data is interpreted

Algorithms:
Step by step instructions for solving some problem

Ultimately, the goal of a programmer is to translate algorithms into computer programming code like C or Python in order to solve real-world problems

Often before diving into code directly though, we'll first sketch out the algorithm using English-like phrases called Pseudocode!

Anatomy of Pseudocode:
- Functions
- Conditionals
- Boolean Expressions
- Loops

[SCRATCH TUTORIAL, see video]
Keywords:
- Function & Arguments
- Output/side effect
- Return Value
- Variable
- User-Defined Functions

WEEK 1 - C

In the real world, programmers write source code! This week we'll be focusing on the C language to write the source code for our programs.

But ultimately, computers only understand machine code (aka binary 0's and 1's) - so how does the computer understand our source code?

Via a compiler! A program that converts source code into machine code!

[See video for example program]

Escape sequences:
- \n
- \r
- \"
- \'
- \\

Header files:
#include <stdio.h>

grants access to the desired libraries

Libraries:
Collections of code that someone else wrote for you

Note: The #include <> is similar to an import statement in Python

Useful Terminal Commands:
- cd		"Change Directory" (Not specifying a directory afterwards will simply take you back to root)
- cp		"Copy"
- ls		"List"
- mkdir		"Make Directory"
- mv		"Move" (Can also be used to rename a file)
- rm		"Remove"
- rmdir		"Remove Directory"

C Variable Data Types:
- string
- int
- float (typically offering about 6-7 decimal digits of precision)
- double (providing significantly more precision, usually around 15-17 decimal digits.)
- long (for really long integers)
- char (for single characters)
- bool

Format Codes (To use with printf):
- %c
- %f
- %i
- %li
- %s

Conditionals:
if x (condition), then y (side effect)


Example In C:
if ( x > y )
{
 printf("x is greater than y\n");
}


Example using if...else:
if (x > y)
{
 printf("x is greater than y\n");
}
else
{
  printf("x is NOT greater than y\n");
}

Example using if... else if:
if (x > y)
{
 printf("x is greater than y\n");
}
else if (x < y)
{
  printf("x is less than y\n");
}
else if (x == y) // note that if x and y are both numbers this condition is uneccessary
{
  printf("x is equal to y\n");
}

Comparitive Operators:
- =
- <
- <=
- >
- >=
- ==
- !=

Variables:
int counter = 0;
counter = counter + 1 //OR counter +=1 OR counter++

Why don't we import ALL the libraries available for C when we run a program?
PERFORMANCE! The less code we have to load and run, the faster our program runs

Logical Operators:
- || OR
- && AND

Loops:
- While Loop Syntax:
while (condition)
{
	side effect;
}
- For Loop Syntax:
for (int i = 0; i < 3; i++)
{
	printf("meow\n")
}

Do-While Loops:
do
{
	side effect
}
while (condition);

NOTE: You can press Control-C to interrupt a program that's stuck looping infinitely. To do so programatically, use the break keyword

User-Defined Functions:
In C:
void func_name(void)
{
	side effect;
}

KEEP IN MIND VARIABLE SCOPE!
- Global
- Local

EVALUTING THE QUALITY OF CODE:
Assess your code based on:
- correctness
- design
- style

CONSTANTS:
- variables that should NEVER change after being initially declared
ex:
const int n = 3

COMMENTS:
- //

MATHEMATIC OPERATORS:
- +
- -
- *
- / (NOTE: Beware of truncation if dividing by two integers!)
- **
- %

CASTING:
Ex)
int x = 1;
int y = 2;

printf("%f\n", (float) x/y); //NOTE: BEWARE FLOATING-POINT IMPRECISION!

WEEK 02 - ARRAYS
Command Line Arguments - Arguments that modify how a command runs in a CLI program

But what does it actually mean to "compile" code?
Compiling is a multi-step process consisting of the following:
Perfect ‚Äî here‚Äôs how CS50 introduces the **four main stages of compiling** (which happen under the hood when you run something like `make hello` or `clang hello.c -o hello`):

---

### üß© **1) Preprocessing**

* The **preprocessor** handles all lines that begin with `#`, such as `#include` and `#define`.
* It **copies in the contents** of header files (like `stdio.h` and `cs50.h`) and **expands macros** before the compiler sees your code.
* Result: a single expanded source file with all includes and macros resolved.

üß† Example:

```c
#include <stdio.h>
#define PI 3.14
```

becomes (conceptually):

```c
// contents of stdio.h here
double pi = 3.14;
```

---

### ‚öôÔ∏è **2) Compiling**

* The **compiler proper** translates the preprocessed C code into **assembly language** (human-readable instructions specific to your CPU architecture).
* This is where most **syntax errors** are caught.
* Result: an **assembly file** (`.s`) that describes low-level operations.

üß† Think of this step as:
C ‚Üí Assembly

---

### ‚öôÔ∏è **3) Assembling**

* The **assembler** converts the assembly code into **machine code** (binary).
* It outputs an **object file** (`.o`) ‚Äî a partially compiled file that the computer can‚Äôt yet run on its own because it might still depend on external code (like library functions).
* Result: `.o` file containing raw machine instructions.

üß† Think of this step as:
Assembly ‚Üí Object (binary code)

---

### üß± **4) Linking**

* The **linker** combines your object file(s) with any **libraries** you‚Äôre using (like `libcs50` or the C standard library).
* It resolves external references ‚Äî for example, when your code calls `printf()`, the linker connects that call to the compiled code for `printf` in the library.
* Result: a single **executable program** (like `hello`).

üß† Think of this step as:
Object files + Libraries ‚Üí Executable

---

### üß† Summary Table

| Step                 | Tool         | Input             | Output          | Purpose                             |
| -------------------- | ------------ | ----------------- | --------------- | ----------------------------------- |
| **1. Preprocessing** | Preprocessor | `.c` source       | expanded source | handle `#include` / `#define`       |
| **2. Compiling**     | Compiler     | preprocessed code | `.s` assembly   | translate C ‚Üí assembly              |
| **3. Assembling**    | Assembler    | `.s` assembly     | `.o` object     | translate assembly ‚Üí machine code   |
| **4. Linking**       | Linker       | `.o` files + libs | executable      | combine everything into one program |

---

DEBUGGING
Common Techniques for Debugging:
- Rubber Duck Debugging
- Printing line by line (or chunk by chunk)
- IDE debugger tool

DATA STRUCTURES
Array - a sequence of values of the same data type back to back to back in memory
int scores[3];
scores[0] = 72;
scores[1] = 73;
scores[2] = 33;

String - a string, in memory, is essentially the same as an array of characters (it actually includes a "termination" character NUL, sometimes denoted with \0, unbeknownst to most users that specifies to end it in memory)

COMMAND-LINE ARGUMENTS
arguments included in the command line when executing a program that modify how it runs
- argc stands for "argument count" and represents the number of command-line arguments passed to the program, including the program's name itself.
- argv stands for "argument vector" and is an array of strings (character arrays) that contains the actual arguments. argv[0] is the name of the program, and argv[1] to argv[argc-1] are the additional arguments.


EXIT STATUS
But why does int main(void) return an int?

## WEEK 03 - ALGORITHMS
Computers can't "see" the contents of their memory without methodically checking a memory address.

When searching for data stored in memory, we employee different algorithms to attempt to find the data as efficiently as possible. This gives rise to different categories of algorithms that define each approach.

### Types of Algorithms

#### Linear Search
- Searching one-by-one "left to right" metaphorically

#### Binary Search
- "Divide and conquer" 

But how do we define the efficiency of an algorithm?

### Running Time
### Measuring the Worst-Case Scenario: Big O Notation
Examples:
- O(1)
- O(n) - linear search
- O(n**2)
- O(log n) - binary search

### Measuring the Best-Case Scenario: Œ©
- Œ©(1) - aka one step
- Œ©(n)
- Œ©(n**2)
- Œ©(log n)

### When they're both the same: Œ∏
- Œ∏(1) - aka one step
- Œ∏(n)
- Œ∏(n**2)
- Œ∏(log n)

All of these are examples of Asymtotic Notation

### Data Structures
Data structures are
ways to organize, store, and manage data in a computer for efficient access and manipulation, forming the backbone of software by defining relationships between data and the operations that can be performed on it, with common types including arrays, linked lists, stacks, queues, trees, and graphs, crucial for building everything from databases to search engines. They allow for performance optimization by choosing the right structure for the task, balancing efficiency in searching, inserting, and deleting data.

We can define our own custom Data structures in C using the typedef struct command:

typedef struct
{
	string name;
	string number;
}
person;

### Sorting
- Selection Sort (not very efficient)
- Bubble Sort

### Recursion
A recursive algorithm is an algorithm which calls itself with "smaller (or simpler)" input values, and which obtains the result for the current input by applying simple operations to the returned value for the smaller (or simpler) input.

### Merge Sort

## WEEK 04: MEMORY
hexidecimal - base 16

We can use the "&" character to refer to the memory address of a variable, as in:
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n",&n);
}

### Pointers
Pointers in programming are variables that store the memory address of another variable, allowing indirect access and manipulation of data, crucial for dynamic memory, efficient data structures (like linked lists), and function arguments, though they require careful handling to avoid errors like null pointer dereferences.

Ex:
int n = 50;
int *p = &n;

#### Pointer Arithemetic
We can do arithemetic on pointers to access nearby memory addresses. For example:

char *s = "HI!";
printf("%c\n",*s);
printf("%c\n",*(s + 1));
printf("%c\n",*(s + 2));

#### Copying Strings
It turns out we can't simply set string1 = string2 to create a unique copy of a string variable. Since char * is really just a pointer in C, we need to take a different approach.

Malloc and Free
When can directly tell the computer to reserve sections of the memory for using malloc, although afterwards we need to be sure to "Free" it aftewards to avoid "memory leaks"

In the C programming language,
malloc and free are the fundamental functions used for dynamic memory management. They allow programs to request memory from the system at runtime (from the "heap") and release it when it is no longer needed. 
1. malloc (Memory Allocation)
The malloc function reserves a specific block of memory on the heap. 

    Syntax: void *malloc(size_t size);
    Parameters: It takes one argument: the total number of bytes to allocate.
    Return Value: It returns a void* (void pointer) to the first byte of the allocated block. If the system cannot fulfill the request (e.g., out of memory), it returns NULL.
    Initialization: The memory is not initialized; it contains "garbage" values from previous uses. 

2. free (Memory Deallocation)
The free function releases previously allocated memory back to the system so it can be reused. 

    Syntax: void free(void *ptr);
    Parameters: It takes the pointer originally returned by malloc (or calloc/realloc).
    Return Value: It does not return any value (void).
    Behavior: If the pointer passed is NULL, the function does nothing. Attempting to free a pointer that has already been freed (a "double free") or was not returned by an allocation function results in undefined behavior. 

Key Usage Rules

    Include Header: Both functions are defined in the <stdlib.h> header file.
    Match Every Malloc: Every successful call to malloc should have a corresponding call to free to prevent memory leaks.
    Check for NULL: Always verify that malloc did not return NULL before using the returned pointer to avoid program crashes.
    Dangling Pointers: After calling free(ptr), the pointer ptr still holds the memory address, but that memory is no longer safe to access. It is good practice to set the pointer to NULL after freeing it. 

Comparison with C++ Alternatives
While malloc and free can be used in C++, it is standard practice to use new and delete instead. 

    new automatically calculates the size based on the type and calls the object's constructor.
    delete calls the object's destructor before releasing the memory.
    malloc and free do not invoke constructors or destructors; they only handle raw bytes of memory. 

Use a program like Valgrind to check your program for memory leaks

Memory Layout goes as follows:
- Machine code
- globals
- heap
|
V
^
|
- stack

Passing by reference:


Stack and heap overflows are
critical memory management failures that occur in different regions of a program's memory. While both can lead to application crashes or security vulnerabilities, they differ in their cause and impact. 
Stack Overflow
A stack overflow occurs when the call stack‚Äîthe memory reserved for tracking function calls and local variables‚Äîexceeds its pre-allocated limit. 

    Primary Cause: Typically caused by excessively deep or infinite recursion where each call adds a new frame to the stack until it runs out of space. It can also occur if very large arrays are declared as local variables.
    Security Risk: A specific type known as a stack buffer overflow occurs when data written to a buffer on the stack overwrites adjacent memory, such as a function's return address. Attackers can exploit this to redirect program execution to malicious code, often called "stack smashing".
    Management: Handled automatically by the system; memory is freed immediately when a function ends. 

Heap Overflow
A heap overflow occurs when a program writes more data than intended into a memory block allocated on the heap‚Äîthe region used for dynamic memory allocation at runtime. 

    Primary Cause: Improper bounds checking when using functions like malloc(), calloc(), or memcpy(). It can also refer to heap exhaustion, where a program continuously requests memory (often due to a memory leak) until no more is available.
    Security Risk: Because the heap stores complex data structures, objects, and metadata, an overflow can corrupt linked-list pointers or function pointers, leading to arbitrary code execution or system instability.
    Management: Handled manually by the programmer; memory must be explicitly allocated and deallocated (freed). 

Both are specfic cases of what's generally referred to as a buffer overflow

### File I/O


## WEEK 05: DATA STRUCTURES
### Abstract Data Types
#### Queues
Queues use FIFO priority - First In First Out!
- enqueue
- dequeue